# Vue.js Fundamentals

Vue.js is one of the most lightweight and enjoyable front-end development frameworks for building modern web applications

* [Vue.js Fundamentals](#vuejs-fundamentals)
  * [Getting Started](#getting-started)
    * [Prerequisites](#prerequisites)
    * [Setting up environment](#setting-up-environment)
    * [Preparations](#preparations)
  * [Fundamentals](#fundamentals)
    * [Vue Structure](#vue-structure)

## Getting Started

The below instructions will get you a copy of the project and running on your local machine for deployment and testing purposes. It will also give some materials for the technology basis on how to get started.

### Prerequisites

* Programming
* HTML
* JavaScript is preferred

### Setting up environment

  1. Install: [Git](https://git-for-windows.github.io) - The version control
  2. Install: [Node js environment](https://github.com/coreybutler/nvm-windows/releases)
     1. Download the `nvm-setup.zip` file for the most recent release.
  3. Install the current release of Node.js (for testing the newest feature improvements, but more likely to have issues than the LTS version): `nvm install latest`
  4. Install the latest stable LTS release of Node.js (recommended) by first looking up what the current LTS version number is with: `nvm list available`, then installing the LTS version number with: `nvm install <version>` (replacing `<version>` with the number, ie: `nvm install 12.14.0`).
  5. List what versions of Node are installed: `nvm ls`
  6. Start NVM environment version like this `nvm use 8.11.2`

* [Reference](https://docs.microsoft.com/en-us/windows/dev-environment/javascript/nodejs-on-windows)

### Preparations

  1. Vue CLI is recommended if the project is planned to be deployed on production environment. As the Vue team created an environment where it can be easily work in development and when it is ready, it create an optimized production build.
    1.a To install CLI, from Bash, `npm install -g @vue/cli` or by specific version like this `npm install -g @vue/cli@3.0.0-rc.3`

  2. Create a new project by `vue create {new-project-name}`

  3. Install these extensions in VSCode:

     * ESLint
     * Vetur
     * vue

  4. For windows users a rule has to be added to handle windows line endings correctly.

     * in .eslintrc.js file add the below lines

       ```js
       rules:{
         "linebreak-style":0
       }
       ```

  5. To compile the application for development and then start a development server for us on port 8080, run serve script from Bash/project_directory by `npm run serve`

## Fundamentals

### Vue Structure

1. src>main.js is the entry point of vue application,
  `new Vue({options object to configure vue Application})` is creating a new Vue instance

2. src>App.vue consists of three sections template, script and style these cannot be read by browser instead there is a vue-specific webpack plugin being used to parse this file into its individual parts and compile them in a way that browser can use them and then this component was passed to the Vue instance, so vue will work with what's generated by webpack.

### Terminologies

#### Component

* A new component is created for each new page
* It is just a Vue Instance to get something to render in Vue

  ```V
  new Vue({
    template: '<div>Hello World</div>', //an option object
    el: '#app',                         //which element on the page to mount this template in
  });
  ```

1. ##### Global components

    * If I want to break things up into smaller, reusable components.

      ```V
      const World = Vue.component(
        'World',                            //Name of the component
        { template: '<span>World</span>' },
      );
      new Vue({
        template: '<div>Hello <World/></div>',//It's just a global constant that could be used    anywhere
        el: '#app',
      });
      ```

    * Limitations

      1. In large applications, global variables envitably cause problems because they can be hard to locate, but it is easy to run into naming conflicts.
      2. It uses string templates. All HTML files has to be defined inside a JavaScript string, you don't get any syntax highlighting, and you end up doing a lots of escaping.
      3. While they nicely encapsulate your HTML template and component logic, CSS is completely kept out of the encapsulation requiring to rely on global CSS styling.
      4. It has no build-time compilation support, means you can do any sort of preprocessing with things like Babel.

2. ##### Single-file component

    * It is a file with a Vue extension.
    * It doesn't has Global component limitations.
    * A Vue instance consists of three sections, template , script and styling; the template and script are required. The template section is where HTML template is defined. The script section is where component JS functionality is defined and where it is exported so it can be imported elsewhere. And finally, the style section is where CSS classes is defined.

#### Data function in script section

* In order to provide data into the component.

### Playing around

#### 1. Rename component

* Rename HelloWorld.vue file to HomePage.vue. Notice that according to Vue styling guides, components should be min two words.

* Rename its name in the file script itself
* Finally, change in App.vue

#### 2. Create new component

* Create a new file with extension .vue
* Create the three sections(template, script, style) in this file
* Import it in the APP.vue

#### 3. Add data to component

* In order to provide data to the component, add data function to the component options

  ```js
  <script>
  export default {
    name: 'RobotBuilder',
    data(){
      return{};
    },
  };
  </script>
  ```

* Import the data file into the component

  ```js
  import AvailableParts from '../data/part.js';
  ```

* Return the data file from the data function

  ```js
  <script>
  import AvailableParts from '../data/part.js';

  export default {
    name: 'RobotBuilder',
    data(){
      return{
        AvailableParts, // return imported data files
        };
    },
  };
  </script>
  ```

* Bind attributes to the data with `v-bind`

  ```html
  <img v-bind:src="AvailableParts.bases[0].src"   title="left arm"/>
  ```

* There is an abbreviation for `v-bind` which is `:`

  ```html
  <img :src="AvailableParts.bases[0].src" title="left   arm"/>
  ```

#### 4. Add events to the elements

* React to actions by the user by binding to the events of these elements with `v-on`

  ```html
  <button v-on:click="selectNextHead()"   class="next-selector">&#9658;</button>
  ```

* There is an abbreviation for `v-on` which is `@`

  ```html
  <button @click="selectNextHead()"   class="next-selector">&#9658;</button>
  ```

* Add a new object to the component script called `methods` property.
* Define each of the functions inside.

  ```js
  <script>
  import AvailableParts from '../data/part.js';

  // A user defined function
  function getPreviousValidIndex(index, length) {
    const oldIndex = index + 4;
    return (oldIndex % length);
  }

  // A user defined function
  function getNextValidIndex(index, length) {
    const oldIndex = index + 1;
    return (oldIndex % length);
  }

  export default {
    name: 'RobotBuilder',
    data() { // This object to manipulate with the  component data
      return {
        AvailableParts,
        selectedHeadIndex: 0, // return a variable and  initiate it with 0
      };
    },
    methods: { // this object to define functions in, to  be called in the component
      selectNextHead() { // Function name
        console.log(this.selectedHeadIndex); // returns   to the console log
        this.selectedHeadIndex = getNextValidIndex  (this.selectedHeadIndex,
          AvailableParts.heads.length); // calls  getNextValidIndex and assign it  selectedHeadIndex
      },
      selectPreviousHead() {
        console.log(this.selectedHeadIndex);
        this.selectedHeadIndex = getPreviousValidIndex  (this.selectedHeadIndex,
          AvailableParts.heads.length);
      },
    },
  };
  </script>
  ```

#### 5. Create Complex Calculations

* It is not a good idea to create complex calculations in HTML
* Add `computed()` object to component script

  ```js
    computed: {
      selectedRobot() {
        return {
          head: AvailableParts.heads  [this.selectedHeadIndex],
          leftArm: AvailableParts.arms  [this.selectedLeftArmIndex],
          torso: AvailableParts.torsos  [this.selectedTorsoIndex],
          rightArm: AvailableParts.arms [this.selectedRightArmIndex],
          base: AvailableParts.bases  [this.selectedBaseIndex],
        };
      },
    },
  ```

* Call this function in the template as below

  ```html
  <img :src="selectedRobot.head.src" title="head"/>
  ```

#### 6. Interpolation

* It is for text data in the webpage
* It is by adding the text inside `{{}}`

  ```js
  {{selectedRobot.head.title}}
  ```

#### 7. Conditionally show content

* `v-if` and `v-show` both can be used for conditioning. If the condition returns a Boolean true then show content

  ```html
  <span v-if="selectedRobot.head.onSale"  class="sale">Sale!</span>
  ```

  ```html
  <span v-show="selectedRobot.head.onSale"  class="sale">Sale!</span>
  ```

* The difference between both is that for `v-if` removes the element completely from the DOM, while `v-show` just changes styling to be `Display = None`.
* `v-show` is preferred to be used if the content is expensive in rendering and the occurrence is frequent, if not then `v-if` is perfect

#### 8. Repeat elements with v-for

* Variables has to initialized in the data object. Otherwise, Vue won't notice the change. And that's because Vue change detection works by hooking getters and setters of properties in the data function.
* You can iterate inside an enumerable function like this `v-for="robot in cart"`, this will iterate for each robot in the cart array.
* Vue need to, for performance reasons, to identify each element in there for updates. So, a unique attribute needs to be added.

  ```js
  v-for="(robot, index) in cart" :key="index"
  ```

* Performance consideration: It is not recommended to add v-if and v-for to the same element

#### 9. Reference child components

* The child component needs to be imported

  ```js
  import PartSelector from './PartSelector'
  ```

* It also needs to be listed in the components array on the parent component
  
  ```js
  components: [PartSelector],
  ```

* This makes our component aware of the child in order to be used.

#### 9. Passing data from child component to its parent using attributes

* First, add the attribute to props function in the child component

  ```js
  export default {
    props: ['parts'],
  }
  ```

* Then now, we can bind to this attribute in the parent component.

  ```html
  <part-selector :parts="availableParts.heads"/>
  ```

* The binding is only needed if the value of the attribute is an expression that needs to be evaluated, while if it is hardcoded just like a class name, so no need for binding.

  ```html
  <part-selector
    :parts="availableParts.heads"
    position="top"/>
  ```

#### 10. Add validation to the attributes

* The below code how to add validations (type, required and  to props

```js
props: {
    parts: { type: Array, required: true }, position: { type: String, required: true },
  },
```

* Add a validation for a specific values using `validator` function.
  
  ```js
    props: {
    parts: { type: Array, required: true },
    position: {
      type: String,
      required: true,
      validator(value) {
        return ['left', 'right', 'bottom', 'center', 'top'].includes(value); } },
  },
  ```

#### 11. Passing data from the parent component to child one

* Each vue component has an emit function that can be called to emit an event. By passing the function we want to emit in this case is 'partSelected' and the data we want to pass with.
  
  ```js
  this.$emit('partSelected', this.selectedPart);
  ```
  
  We can put this function inside another function reusability.

  ```js
  methods: {
    emitSelectedPart() {
      this.$emit('partSelected', this.selectedPart);
    },
  ```

  Now we can call emitSelectedPart() function for emitting the data, for example we can call it inside  created() function in order to be used once the page created and/or inside updated() function to be called for any update occurs

  ```js
  created() {
    this.emitSelectedPart();
  },
  updated() {
    this.emitSelectedPart();
  }
  ```

  We can also use it user defined functions as below

  ```js
  methods: {
    emitSelectedPart() {
      this.$emit('partSelected', this.selectedPart);
    },
    selectNextPart() {
      this.selectedPartIndex = getNextValidIndex(
        this.selectedPartIndex,
        this.parts.length,
      );
      this.emitSelectedPart();
    },
    selectPreviousPart() {
      this.selectedPartIndex = getPreviousValidIndex(
        this.selectedPartIndex,
        this.parts.length,
      );
      this.emitSelectedPart();
    },
  ```

  This now means that the parent component can bind to a partSelected event when it creates the PartSelector component
